{-# LANGUAGE DeriveGeneric #-}{-# LANGUAGE OverloadedStrings #-}{-# LANGUAGE TypeFamilies #-}{-# LANGUAGE FlexibleInstances #-}-- | The yao literal that can only be 0 or 1.newtype Yao = Yao Char deriving (Show, Eq)-- | The ToYao typefamily provides a way to convert various types to Yao by uisng the `toYao` functionclass ToYao a where -- | The typefamily wrapper for Yao type YaoType a {-| Converts a type to its Yao counterpart, and raises an error if its "a" is not '0' or '1'. >>> toYao '1' Right (Yao '1') >>> toYao "101010" Right [Yao '1',Yao '0',Yao '1',Yao '0',Yao '1',Yao '0'] >>> toYao $ Just '1' Right $ Just (Yao '1') -} toYao :: a -> Either String (YaoType a)-- | Implement ToYao for the '0' and '1' characters onlyinstance ToYao Char where type YaoType Char = Yao toYao c | c `elem` ['0', '1'] = Right $ Yao c | otherwise = Left "Yao can only be '0' or '1'"instance ToYao Value where type YaoType Value = (Yao, Yao) toYao v | v == Value '6' = toYao ('0','1') | v == Value '7' = toYao ('1','1') | v == Value '8' = toYao ('0','0') | v == Value '9' = toYao ('1','0') | otherwise = Left "" -- this will never occurinstance {-# OVERLAPS #-} ToYao [Value] where type YaoType [Value] = ([Yao], [Yao]) toYao xs | length xs == 6 = bimap sequence sequence $ unzip <$> traverse toValue xs | otherwise = Left "Length of [Yao] and [Value] must be 6"-- | Implement ToYao for strings and lists of charactersinstance {-# OVERLAPS #-} ToYao a => ToYao [a] where type YaoType [a] = [YaoType a] toYao xs | length xs == 6 = traverse toYao xs | otherwise = Left "Length of a [Yao] must be 6"-- | The value literal that can only be 6, 7, 8 or 9newtype Value = Value Char deriving (Show, Eq)-- | The ToValue typefamily provides a way to convert various types to Values by uisng the `toValue` functionclass ToValue a where -- | The typefamily wrapper for Yao type ValueType a {-| Converts a type to its Value counterpart, and raises an error if its "a" is not '6', '7', '8' or '9'. >>> toValue '7' Value '7' >>> toValue "787879" [Value '7',Value '8', Value '7', Value '8', Value '7',Value '9'] >>> toValue $ Just 9 Just (Value '9') -} toValue :: a -> Either String (ValueType a)